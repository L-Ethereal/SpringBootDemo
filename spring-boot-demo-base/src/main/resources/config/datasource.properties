########################################################################################################################
# 使用 Docker 创建 MySQL 容器
########################################################################################################################
# docker 下载 MySQL 镜像
# docker pull mysql
# docker 查看当前镜像
# docker images
# 创建并启动 MySQL 容器
# docker run --name spring-boot-demo-mysql -e MYSQL_ROOT_PASSWORD=springbootdemomysql -p 3306:3306 -d mysql
# –name：给新创建的容器命名，此处命名为ly-mysql
# -e：配置信息，此处配置mysql的root用户的登陆密码
# -p：端口映射，此处映射主机3306端口到容器pwc-mysql的3306端口
# -d：成功启动容器后输出容器的完整ID.
# 最后一个mysql指的是mysql镜像名字
# 查看 docker name
# docker inspect -f='{{.Name}}' $(docker ps -a -q)
# 查看 docker ip
# docker inspect -f='{{.NetworkSettings.IPAddress}}' $(docker ps -a -q)
# 查看 docker 名称、ip 及端口
# docker inspect -f='{{.Name}} {{.NetworkSettings.IPAddress}} {{.HostConfig.PortBindings}}' $(docker ps -aq)
# 查看所有 docker 容器 包括未启动的容器
# docker ps -a
# 查看所有 docker 容器 不包括未启动的容器
# docker ps
# 通过 docker name 进入控制台
# docker exec -it spring-boot-demo-mysql(即 docker name) bash
# 停止 docker 容器
# docker stop spring-boot-demo-mysql
# 启动 docker 容器
# docker start spring-boot-demo-mysql
#
#Docker 是一个 Client-Server 架构的应用，Docker是大家对Docker Engine简称。
#Docker Machine 则是一个安装和管理 Docker 的工具。它有自己的命令行工具：docker-machine
########################################################################################################################

#spring.datasource.url=jdbc:mysql://localhost:3306/test1?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull
#spring.datasource.username=root
#spring.datasource.password=springbootdemomysql
#spring.datasource.driverClassName=com.mysql.jdbc.Driver
#
#spring.datasource.max-idle=10
#spring.datasource.max-active=15
#spring.datasource.max-lifetime=86430000
#spring.datasource.log-abandoned=true
#spring.datasource.remove-abandoned=true
#spring.datasource.remove-abandoned-timeout=60
#spring.datasource.initialize=false
#spring.datasource.sqlScriptEncoding=UTF-8

# 配置多数据源
# 主要用到的是maximum-pool-size这个值，一般情况下读数据库（slave）总会比写（master）要多一些，
# 而且往往是一个master多个slave。所以，maximum-pool-size这个值在master的设置小于slave比较高效
hikari.master.datasource.url=jdbc:mysql://localhost:3306/spring_boot_demo
hikari.master.datasource.username=root
hikari.master.datasource.password=springbootdemomysql
hikari.master.datasource.driverClassName=com.mysql.jdbc.Driver

hikari.master.datasource.maximum-pool-size=20
hikari.master.datasource.pool-name=master
hikari.master.datasource.connection-timeout=30000
hikari.master.datasource.idle-timeout=600000
hikari.master.datasource.max-lifetime=1765000

hikari.slave.datasource.url=dbc:mysql://localhost:3306/spring_boot_demo
hikari.slave.datasource.username=root
hikari.slave.datasource.password=springbootdemomysql
hikari.slave.datasource.driverClassName=com.mysql.jdbc.Driver

hikari.slave.datasource.maximum-pool-size=20
hikari.slave.datasource.pool-name=slave
hikari.slave.datasource.connection-timeout=30000
hikari.slave.datasource.idle-timeout=600000
hikari.slave.datasource.max-lifetime=1765000
hikari.slave.datasource.read-only=true